/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// prepare.ts
var prepare_exports = {};
__export(prepare_exports, {
  default: () => PREPARE_MODULE
});
module.exports = __toCommonJS(prepare_exports);
var path = __toESM(require("path"));
var fsxt = __toESM(require("fs-extra"));
var dotenv = __toESM(require("dotenv"));
var colors = __toESM(require("colors/safe"));
var readline = __toESM(require("readline"));
var PREPARE_MODULE = class {
  /**
   * Creates an instance of the `PREPARE_MODULE` class.
   * @constructor
   * @param {string[]}    entries         - Custom signatures (words) for file content search.
   * @param {string}      extraction_mode - Extraction mode: 'Y' for appending, 'N' for replacing, 'C' for custom.
   */
  constructor(entries, extraction_mode = "C") {
    /**
     * The root directory of the project.
     * @type {string}
     */
    this.ROOT_DIRECTORY = __dirname;
    /**
     * Array of folder names to exclude from directory traversal.
     * @type {string[]}
     */
    this.EXCLUDING_FOLDER = [
      "node_modules",
      "venv",
      ".git",
      "$git",
      "out"
    ];
    /**
     * Array of values to include into file content search.
     * @type {string[]}
     */
    this.EXCLUDING_VALUES = [
      "FALCION",
      "PATTERNU",
      "PATTERNUGIT",
      "PATTERNUGIT.NET"
    ];
    /**
     * Flag indicating whether to update the manifesto file.
     * @type {boolean}
     */
    this.UPDATE_MANIFESTO = false;
    if (extraction_mode == "Y") {
      for (const item of entries)
        this.EXCLUDING_VALUES.push(item);
    }
    if (extraction_mode == "N") {
      this.EXCLUDING_VALUES = this.EXCLUDING_VALUES;
    }
    if (extraction_mode == "C") {
      this.EXCLUDING_VALUES = entries;
    }
  }
  /**
   * Asynchronously searches for custom signatures (words) in the content of a file.
   * @param {string}      filepath    - The path of the file to search.
   * @param {string[]}    data        - Custom signatures (words) to search for.
   * @returns {Promise<void>}
   */
  __search_directory(filepath, data) {
    return __async(this, null, function* () {
      const filedata = yield fsxt.readFile(filepath, "utf-8");
      const contents = filedata.split("\n");
      for (let i = 0; i < contents.length; i++) {
        const line = contents[i].toUpperCase();
        for (const target of data)
          if (line.includes(target))
            console.info(colors.green(`Found "${target}" in L#${i} of:
` + colors.cyan(filepath)));
      }
    });
  }
  /**
   * Asynchronously traverses a directory, searching for files and directories.
   * @param {string} directory - The directory to traverse.
   * @returns {Promise<void>}
   */
  __traverse_directory(directory) {
    return __async(this, null, function* () {
      try {
        const files = yield fsxt.readdir(directory);
        for (const file of files) {
          const filepath = path.join(directory, file);
          const filestat = yield fsxt.stat(filepath);
          if (filestat.isDirectory()) {
            if (!this.EXCLUDING_FOLDER.includes(file)) {
              yield this.__traverse_directory(filepath);
            }
          } else if (filestat.isFile()) {
            yield this.__search_directory(filepath, this.EXCLUDING_VALUES);
          } else
            continue;
        }
      } catch (err) {
        console.error(colors.red(`Error via reading given directory: ${err}`));
      }
    });
  }
  /**
   * Asynchronously prepares project files, such as .env and manifest.json.
   * @returns {Promise<void>}
   */
  __prepare_project() {
    return __async(this, null, function* () {
      const input1 = [
        "# Type here any requested keys, token or other, for example, API or connection data",
        "EXAMPLE_API_KEY="
      ].join("\n");
      const input2 = JSON.stringify({}, void 0, 2);
      if (yield fsxt.exists(path.join(__dirname, ".env"))) {
        yield fsxt.ensureFile(path.join(__dirname, ".env"));
        yield fsxt.writeFile(
          path.join(__dirname, ".env"),
          input1
        );
      }
      if (yield fsxt.exists(path.join(__dirname, "manifest.json"))) {
        yield fsxt.ensureFile(path.join(__dirname, "manifest.json"));
        yield fsxt.writeFile(
          path.join(__dirname, "manifest.json"),
          input2
        );
      }
      if (this.UPDATE_MANIFESTO == void 0 || this.UPDATE_MANIFESTO == false) {
        return;
      }
      const PACKAGER = JSON.parse(yield fsxt.readFile("package.json", { encoding: "utf-8" }));
      const MANIFEST = JSON.parse(yield fsxt.readFile("manifest.json", { encoding: "utf-8" }));
      if (PACKAGER.name === MANIFEST.id && PACKAGER.displayName === MANIFEST.name && PACKAGER.description === MANIFEST.description && PACKAGER.author.name === MANIFEST.author && PACKAGER.author.url === MANIFEST.authorUrl && PACKAGER.license === MANIFEST.license && PACKAGER.version === MANIFEST.version) {
        console.warn(colors.bgGreen(colors.white("Manifest is synced with package, keep everything as it was.")));
      } else {
        console.warn(colors.bgBlue(colors.yellow("Manifest is not synced with package's information, rewriting it.")));
        yield fsxt.copyFile(
          "manifest.json",
          "manifest-backup.json"
        );
        const data = {
          "id": PACKAGER.name,
          "name": PACKAGER.displayName,
          "description": PACKAGER.description,
          "author": PACKAGER.author.name,
          "authorUrl": PACKAGER.author.url,
          "license": PACKAGER.license,
          "version": PACKAGER.version
        };
        yield fsxt.writeFile("manifest.json", JSON.stringify(data, void 0, 2));
      }
    });
  }
};
dotenv.config({
  path: ".env",
  encoding: "utf-8"
});
var RL = readline.createInterface({ input: process.stdin, output: process.stdout });
RL.question(colors.bold("Change signatures of manifesto (JSON) for the repository [Y/N]: "), (input) => {
  if (input.toUpperCase() == "Y") {
    new PREPARE_MODULE([], "C").__prepare_project();
    RL.close();
  } else if (input.toUpperCase() == "N") {
    RL.close();
  }
});
RL.question(colors.bold("Change finding signatures (words) for the finder script [Y/N/C]: "), (answer) => {
  if (answer.toUpperCase() == "Y") {
    RL.question(colors.bold("Enter your custom signatures (words) separatedly by commas: "), (addition) => {
      const input = addition.split(",");
      new PREPARE_MODULE(input, "Y").__traverse_directory(__dirname);
      RL.close();
    });
  } else if (answer.toUpperCase() == "C") {
    RL.question(colors.bold("Enter your custom signatures (words) separatedly by commas: "), (addition) => {
      const input = addition.split(",");
      new PREPARE_MODULE(input, "C").__traverse_directory(__dirname);
      RL.close();
    });
  } else if (answer.toUpperCase() == "N") {
    new PREPARE_MODULE([], "N").__traverse_directory(__dirname);
    RL.close();
  }
  RL.close();
});
